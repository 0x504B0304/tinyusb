/* 
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Ha Thach (tinyusb.org)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file is part of the TinyUSB stack.
 */

#include <stdio.h>
#include "unity.h"
#include "common/binary.h"

void setUp(void)
{
}

void tearDown(void)
{
}

void test_binary_8(void)
{
  TEST_ASSERT_EQUAL_HEX8(0x00, TU_BIN8(00000000));
  TEST_ASSERT_EQUAL_HEX8(0x01, TU_BIN8(00000001));
  TEST_ASSERT_EQUAL_HEX8(0x02, TU_BIN8(00000010));
  TEST_ASSERT_EQUAL_HEX8(0x04, TU_BIN8(00000100));
  TEST_ASSERT_EQUAL_HEX8(0x08, TU_BIN8(00001000));
  TEST_ASSERT_EQUAL_HEX8(0x10, TU_BIN8(00010000));
  TEST_ASSERT_EQUAL_HEX8(0x20, TU_BIN8(00100000));
  TEST_ASSERT_EQUAL_HEX8(0x40, TU_BIN8(01000000));
  TEST_ASSERT_EQUAL_HEX8(0x80, TU_BIN8(10000000));

  TEST_ASSERT_EQUAL_HEX8(0x0f, TU_BIN8(00001111));
  TEST_ASSERT_EQUAL_HEX8(0xf0, TU_BIN8(11110000));
  TEST_ASSERT_EQUAL_HEX8(0xff, TU_BIN8(11111111));
}

void test_binary_16(void)
{
  TEST_ASSERT_EQUAL_HEX16(0x0000, TU_BIN16(00000000, 00000000));
  TEST_ASSERT_EQUAL_HEX16(0x000f, TU_BIN16(00000000, 00001111));
  TEST_ASSERT_EQUAL_HEX16(0x00f0, TU_BIN16(00000000, 11110000));
  TEST_ASSERT_EQUAL_HEX16(0x0f00, TU_BIN16(00001111, 00000000));
  TEST_ASSERT_EQUAL_HEX16(0xf000, TU_BIN16(11110000, 00000000));
  TEST_ASSERT_EQUAL_HEX16(0xffff, TU_BIN16(11111111, 11111111));
}

void test_binary_32(void)
{
  TEST_ASSERT_EQUAL_HEX32(0x00000000, TU_BIN32(00000000, 00000000, 00000000, 00000000));
  TEST_ASSERT_EQUAL_HEX32(0x0000000f, TU_BIN32(00000000, 00000000, 00000000, 00001111));
  TEST_ASSERT_EQUAL_HEX32(0x000000f0, TU_BIN32(00000000, 00000000, 00000000, 11110000));
  TEST_ASSERT_EQUAL_HEX32(0x00000f00, TU_BIN32(00000000, 00000000, 00001111, 00000000));
  TEST_ASSERT_EQUAL_HEX32(0x0000f000, TU_BIN32(00000000, 00000000, 11110000, 00000000));
  TEST_ASSERT_EQUAL_HEX32(0x000f0000, TU_BIN32(00000000, 00001111, 00000000, 00000000));
  TEST_ASSERT_EQUAL_HEX32(0x00f00000, TU_BIN32(00000000, 11110000, 00000000, 00000000));
  TEST_ASSERT_EQUAL_HEX32(0x0f000000, TU_BIN32(00001111, 00000000, 00000000, 00000000));
  TEST_ASSERT_EQUAL_HEX32(0xf0000000, TU_BIN32(11110000, 00000000, 00000000, 00000000));
  TEST_ASSERT_EQUAL_HEX32(0xffffffff, TU_BIN32(11111111, 11111111, 11111111, 11111111));
}

void test_bit_set(void)
{
  TEST_ASSERT_EQUAL_HEX32( TU_BIN8(00001101), tu_bit_set( TU_BIN8(00001001), 2));
  TEST_ASSERT_EQUAL_HEX32( TU_BIN8(10001101), tu_bit_set( TU_BIN8(00001101), 7));
}

void test_bit_clear(void)
{
  TEST_ASSERT_EQUAL_HEX32( TU_BIN8(00001001), tu_bit_clear( TU_BIN8(00001101), 2));
  TEST_ASSERT_EQUAL_HEX32( TU_BIN8(00001101), tu_bit_clear( TU_BIN8(10001101), 7));
}
